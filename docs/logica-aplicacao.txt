================================================================================
PRIORITYFLOW - DASHBOARD DE TRIAGEM DE TICKETS
DOCUMENTAÇÃO COMPLETA DA LÓGICA DA APLICAÇÃO
================================================================================

DATA: 2025
VERSÃO: 1.0
AUTOR: BLACKBOXAI

================================================================================
ÍNDICE
================================================================================
1. VISÃO GERAL DA APLICAÇÃO
2. FLUXO PRINCIPAL DE FUNCIONAMENTO
3. LÓGICA DE PRIORIZAÇÃO
4. ESTRUTURA DE DADOS
5. FUNÇÕES PRINCIPAIS
6. ASPECTOS TÉCNICOS
7. INTERFACE E EXPERIÊNCIA DO USUÁRIO
8. COMO TESTAR A APLICAÇÃO
9. CONSIDERAÇÕES PARA PRODUÇÃO

================================================================================
1. VISÃO GERAL DA APLICAÇÃO
================================================================================

PriorityFlow é um dashboard web para triagem automática de tickets de suporte
técnico. A aplicação classifica tickets por prioridade baseada exclusivamente
no tipo de cliente, sem análise de conteúdo da descrição.

TECNOLOGIAS UTILIZADAS:
- Frontend: HTML5, CSS3, JavaScript (Vanilla)
- Backend: Simulado (Array JavaScript)
- Estilo: Design system moderno com Inter font
- Responsividade: CSS Grid e Flexbox

================================================================================
2. FLUXO PRINCIPAL DE FUNCIONAMENTO
================================================================================

FASE 1: INICIALIZAÇÃO
- DOMContentLoaded dispara setup da aplicação
- loadTickets() carrega tickets existentes (inicialmente vazio)
- Event listeners configurados para formulário e botão de processamento

FASE 2: CRIAÇÃO DE TICKETS
- Usuário preenche formulário (título, descrição, tipo cliente)
- Validação frontend obrigatória (campos não podem estar vazios)
- Ticket criado com status 'PENDENTE' e adicionado à fila
- Interface atualizada com novo ticket

FASE 3: PROCESSAMENTO DA FILA
- Botão "Processar Fila Pendente" clicado
- Todos os tickets com status 'PENDENTE' são processados
- Para cada ticket:
  * Status muda para 'CLASSIFICADO'
  * Prioridade calculada baseada no tipo_cliente
  * Badge visual atribuído
- Interface atualizada mostrando tickets classificados

FASE 4: VISUALIZAÇÃO CONTÍNUA
- Tickets organizados em duas filas visuais
- Fila Pendente: tickets aguardando classificação
- Fila Classificada: tickets com prioridade definida
- Ordenação por data (mais recentes primeiro)

================================================================================
3. LÓGICA DE PRIORIZAÇÃO
================================================================================

REGRA PRINCIPAL: A prioridade é determinada EXCLUSIVAMENTE pelo tipo de cliente.
A descrição do ticket NÃO influencia na classificação.

MAPEAMENTO DE PRIORIDADES:

TIPO_CLIENTE = 'PREMIUM'  → PRIORIDADE = 'CRÍTICA' (vermelho #E53935)
TIPO_CLIENTE = 'BASICO'   → PRIORIDADE = 'ALTA'    (amarelo #FDD835)
TIPO_CLIENTE = 'GRATUITO' → PRIORIDADE = 'BAIXA'   (verde #43A047)

JUSTIFICATIVA DA LÓGICA:
- Premium: Clientes pagantes têm prioridade máxima
- Básico: Clientes pagantes têm prioridade alta
- Gratuito: Clientes não-pagantes têm prioridade baixa

IMPLEMENTAÇÃO EM CÓDIGO:
function calculateUrgency(clientType, description) {
    if (clientType === 'PREMIUM') {
        return 'CRÍTICA';
    } else if (clientType === 'BASICO') {
        return 'ALTA';
    } else { // GRATUITO
        return 'BAIXA';
    }
}

================================================================================
4. ESTRUTURA DE DADOS
================================================================================

OBJETO TICKET:
{
    id: number,              // ID único (timestamp)
    titulo: string,          // Título do ticket (obrigatório)
    descricao: string,       // Descrição detalhada (obrigatório)
    tipo_cliente: string,    // 'PREMIUM' | 'BASICO' | 'GRATUITO'
    status: string,          // 'PENDENTE' | 'CLASSIFICADO'
    urgencia_calculada: string | null, // 'CRÍTICA' | 'ALTA' | 'BAIXA' | null
    created_at: string       // Data ISO string
}

ARRAY GLOBAL:
let mockTickets = []; // Simula banco de dados

ESTADOS POSSÍVEIS:
- Status: PENDENTE (aguardando classificação)
- Status: CLASSIFICADO (prioridade definida)
- Urgência: null (não calculada) ou string (CRÍTICA/ALTA/BAIXA)

================================================================================
5. FUNÇÕES PRINCIPAIS
================================================================================

5.1 INICIALIZAÇÃO
document.addEventListener('DOMContentLoaded', () => {
    loadTickets();
    form.addEventListener('submit', createTicket);
    processBtn.addEventListener('click', processQueue);
});

5.2 CARREGAMENTO DE TICKETS
function loadTickets() {
    displayTickets(mockTickets);
}

5.3 RENDERIZAÇÃO DA INTERFACE
function displayTickets(tickets) {
    // Limpa containers
    // Ordena por data (descendente)
    // Filtra por status
    // Renderiza cards HTML
    // Aplica estado vazio se necessário
}

5.4 CRIAÇÃO DE TICKET
function createTicket(event) {
    event.preventDefault();

    // Validação
    if (!titulo || !descricao) {
        showError();
        return;
    }

    // Cria objeto ticket
    const newTicket = {
        id: Date.now(),
        titulo, descricao, tipo_cliente,
        status: 'PENDENTE',
        urgencia_calculada: null,
        created_at: new Date().toISOString()
    };

    // Adiciona ao array
    mockTickets.push(newTicket);

    // Feedback e atualização UI
    showMessage('Sucesso!');
    loadTickets();
}

5.5 PROCESSAMENTO DA FILA
function processQueue() {
    // Loading state
    // Filtra tickets pendentes
    // Para cada ticket:
    //   - status = 'CLASSIFICADO'
    //   - urgencia_calculada = calculateUrgency()
    // Feedback sucesso
    // Atualiza UI
}

5.6 CÁLCULO DE PRIORIDADE
function calculateUrgency(clientType, description) {
    // Lógica pura baseada apenas em clientType
    // description é parâmetro não utilizado (para futuro)
}

5.7 FEEDBACK VISUAL
function showMessage(text, type) {
    // Exibe toast notification
    // Auto-oculta após 5 segundos
}

================================================================================
6. ASPECTOS TÉCNICOS
================================================================================

6.1 ARQUITETURA
- SPA (Single Page Application) vanilla JavaScript
- Separação de responsabilidades: HTML (estrutura), CSS (estilo), JS (lógica)
- Event-driven programming
- Simulação de assincronia com setTimeout

6.2 GERENCIAMENTO DE ESTADO
- Estado global: mockTickets array
- Mutação direta do estado (não imutável)
- Re-render completo da UI após mudanças

6.3 VALIDAÇÃO
- Frontend-only (sem backend)
- Campos obrigatórios: titulo, descricao
- Mensagens de erro inline
- Prevenção de submit com campos vazios

6.4 PERFORMANCE
- Re-renders completos (aceitável para protótipo)
- Simulação de delays para UX realista
- CSS eficiente com seletores otimizados

6.5 ACESSIBILIDADE
- ARIA labels em botões
- Semântica HTML correta
- Contraste de cores adequado
- Navegação por teclado possível

6.6 RESPONSIVIDADE
- Breakpoint principal: 900px
- Mobile: layout empilhado
- Desktop: layout lado a lado
- Flexbox para layouts flexíveis

================================================================================
7. INTERFACE E EXPERIÊNCIA DO USUÁRIO
================================================================================

7.1 LAYOUT GERAL
- Container centralizado (max-width: 1200px)
- Fundo cinza claro (#F6F7F8)
- Card branco com sombra sutil
- Espaçamento consistente (40px padding)

7.2 FORMULÁRIO DE CRIAÇÃO
- Campos: título (input), descrição (textarea), tipo cliente (select)
- Validação visual com mensagens de erro
- Botão com loading state
- Reset automático após sucesso

7.3 VISUALIZAÇÃO DE FILAS
- Duas colunas: Pendente | Classificada
- Cards com título e tipo cliente
- Badges coloridos para prioridade
- Estado vazio com ícone SVG

7.4 FEEDBACK VISUAL
- Toast notifications (sucesso/erro)
- Loading spinners em botões
- Transições suaves (0.2s ease)
- Estados hover e active

7.5 CORES E TIPOGRAFIA
- Font: Inter (fallback system fonts)
- Cores principais: azul (#0B63E4), cinza (#6B7280)
- Prioridades: vermelho (#E53935), amarelo (#FDD835), verde (#43A047)
- Contraste WCAG compliant

================================================================================
8. COMO TESTAR A APLICAÇÃO
================================================================================

8.1 TESTE BÁSICO
1. Abrir frontend/index.html no navegador
2. Criar ticket com título e descrição
3. Selecionar tipo cliente
4. Clicar "Criar Ticket"
5. Verificar ticket na "Fila Pendente"

8.2 TESTE DE CLASSIFICAÇÃO
1. Criar múltiplos tickets com tipos diferentes
2. Clicar "Processar Fila Pendente"
3. Verificar badges de prioridade:
   - Premium → Badge vermelho "CRÍTICA"
   - Básico → Badge amarelo "ALTA"
   - Gratuito → Badge verde "BAIXA"

8.3 TESTE DE VALIDAÇÃO
1. Tentar criar ticket sem título
2. Tentar criar ticket sem descrição
3. Verificar mensagens de erro
4. Verificar que formulário não submete

8.4 TESTE RESPONSIVO
1. Redimensionar janela para < 900px
2. Verificar layout empilhado
3. Testar em dispositivo móvel

8.5 TESTE DE PERFORMANCE
1. Criar 10+ tickets
2. Processar fila
3. Verificar tempo de resposta
4. Verificar ordenação por data

================================================================================
9. CONSIDERAÇÕES PARA PRODUÇÃO
================================================================================

9.1 BACKEND REAL
- Substituir mockTickets por API REST
- Endpoints necessários:
  * GET /tickets - listar todos
  * POST /tickets - criar novo
  * PUT /tickets/process - processar fila

9.2 BANCO DE DADOS
- Tabela tickets com campos do objeto
- Índices em status, created_at
- Relacionamento com usuários/clientes

9.3 AUTENTICAÇÃO
- Sistema de login/logout
- Controle de permissões
- Sessões seguras

9.4 MONITORAMENTO
- Logs de processamento
- Métricas de performance
- Alertas para filas grandes

9.5 ESCABILIDADE
- Paginação para listas grandes
- Cache para tipos de cliente
- Processamento assíncrono em background

9.6 SEGURANÇA
- Validação backend obrigatória
- Sanitização de inputs
- Rate limiting
- HTTPS obrigatório

================================================================================
FIM DA DOCUMENTAÇÃO
================================================================================
